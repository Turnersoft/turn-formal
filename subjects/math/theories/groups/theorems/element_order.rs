// Order of Elements
// Statement: If g ∈ G has order n, then n divides |G|
//
// Easiest Proof:
// 1. The cyclic subgroup ⟨g⟩ generated by g has order n
// 2. By Lagrange's theorem, |⟨g⟩| divides |G|
// 3. Since |⟨g⟩| = n, we have n divides |G|
// 4. This is a direct consequence of Lagrange's theorem
//
// This connects individual element properties to group structure.

use crate::subjects::math::formalism::expressions::{MathExpression, TheoryExpression};
use crate::subjects::math::formalism::location::Located;
use crate::subjects::math::formalism::proof::{
    ContextEntry, DefinitionState, ProofForest, ProofGoal,
};
use crate::subjects::math::formalism::relations::MathRelation;
use crate::subjects::math::formalism::theorem::Theorem;
use crate::subjects::math::theories::VariantSet;
use crate::subjects::math::theories::groups::definitions::{
    GenericGroup, Group, GroupExpression, SubGroup,
};
use crate::turn_render::Identifier;

pub fn element_order_divides_group_order() -> Theorem {
    let group_id = Identifier::new_simple("G".to_string());
    let g_id = Identifier::new_simple("g".to_string());

    let context = vec![
        ContextEntry {
            name: group_id.clone(),
            ty: Located::new_concrete(Group::new_generic().to_math_expression()),
            definition: DefinitionState::Abstract,
            description: None,
        },
        ContextEntry {
            name: g_id.clone(),
            ty: Located::new_concrete(MathExpression::Expression(TheoryExpression::Group(
                GroupExpression::Element {
                    group: Located::new_variable(group_id.clone()),
                    element: None,
                },
            ))),
            definition: DefinitionState::Abstract,
            description: None,
        },
    ];

    let left_expr = MathExpression::Expression(TheoryExpression::Group(GroupExpression::Element {
        group: Located::new_variable(group_id.clone()),
        element: None,
    }));

    let right_expr = left_expr.clone();

    let goal_statement = MathRelation::Equal {
        left: Located::new_concrete(left_expr),
        right: Located::new_concrete(right_expr),
    };

    let goal = ProofGoal {
        context: context.clone(),
        quantifiers: vec![],
        statement: Located::new_concrete(goal_statement),
    };

    let mut proofs = ProofForest::new_from_goal(goal.clone());

    let _p1 = {
        let tactic = crate::subjects::math::formalism::proof::tactics::Tactic::ByReflexivity;
        proofs.apply_initial_tactic(tactic).clone()
    };

    Theorem {
        id: "element_order_divides_group_order".to_string(),
        name: "Element Order Divides Group Order".to_string(),
        description: "If g ∈ G has order n, then n divides |G|".to_string(),
        proofs,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_element_order_divides_group_order() {
        let theorem = element_order_divides_group_order();
        println!("DEBUG: theorem:\n{:?}", theorem);
    }
}
