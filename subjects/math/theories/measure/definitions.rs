use super::super::super::super::math::theories::VariantSet;
use super::super::super::super::math::theories::analysis::definition::spaces::BanachSpace;
use super::super::super::super::math::theories::zfc::set::Set;
use serde::{Deserialize, Serialize};

/// Measure structure
/// A function μ: Σ → [0,∞] on a σ-algebra Σ satisfying:
/// 1. μ(∅) = 0
/// 2. Countable additivity: μ(⋃ᵢEᵢ) = Σᵢμ(Eᵢ) for disjoint sets
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Measure {
    /// Properties of the measure (finiteness, regularity, etc.)
    pub properties: VariantSet<MeasureProperty>,
}

/// Types of σ-algebras that can be defined on a space
/// Each type represents a different way of constructing
/// the collection of measurable sets
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SigmaAlgebraVariant {
    /// Borel σ-algebra: Generated by open sets
    /// B(X) = σ(τ) where τ is the topology
    /// This is the smallest σ-algebra containing all open sets
    Borel,

    /// Lebesgue σ-algebra: Completion of Borel σ-algebra
    /// L(X) = {A ∪ N : A ∈ B(X), N ⊆ Z, Z ∈ B(X), μ(Z) = 0}
    /// Contains all sets differing from Borel sets by null sets
    Lebesgue,

    /// Power set: Collection of all subsets
    /// P(X) = {A : A ⊆ X}
    /// Largest possible σ-algebra on X
    PowerSet,

    /// Generated σ-algebra: σ(C) for some collection C
    /// Smallest σ-algebra containing C
    /// Useful for custom measurable structures
    Generated(String),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MeasureProperty {
    /// Finiteness: total measure is finite
    /// μ(X) < ∞
    Finite(FinitePropertyVariant),

    /// σ-finiteness: countable union of finite measure sets
    /// X = ⋃ᵢXᵢ with μ(Xᵢ) < ∞
    SigmaFinite(SigmaFinitePropertyVariant),

    /// Borel property: defined on Borel σ-algebra
    /// Domain is σ-algebra generated by open sets
    Borel(BorelPropertyVariant),

    /// Hausdorff property: separation by measure
    /// For x≠y, ∃ measurable E: x∈E, y∉E
    Hausdorff(HausdorffPropertyVariant),

    /// Radon property: inner regularity
    /// μ(E) = sup{μ(K): K⊆E compact} for all measurable E
    Radon(RadonPropertyVariant),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RadonPropertyVariant {
    /// Inner regular measure
    /// μ(E) = sup{μ(K): K⊆E compact}
    Radon,
    /// Not Radon
    NonRadon,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum HausdorffPropertyVariant {
    /// Points separable by open sets
    /// x≠y ⟹ ∃U,V open: x∈U, y∈V, U∩V=∅
    Hausdorff,
    /// Not Hausdorff
    NonHausdorff,
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FinitePropertyVariant {
    /// Has finite measure
    /// μ(X) < ∞
    Finite,
    /// Has infinite measure
    Infinite,
}

/// A measurable space (X,Σ) consists of:
/// - A set X of points
/// - A σ-algebra Σ of subsets of X satisfying:
///   1. X ∈ Σ
///   2. A ∈ Σ ⟹ X\A ∈ Σ (closed under complementation)
///   3. {Aₙ}ₙ∈ℕ ⊆ Σ ⟹ ∪ₙ∈ℕ Aₙ ∈ Σ (closed under countable unions)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct MeasurableSpace {
    /// The underlying set X of points
    pub base_set: Set,
    /// The σ-algebra Σ (collection of measurable sets)
    pub sigma_algebra: SigmaAlgebraVariant,
    /// Additional properties
    pub properties: Vec<MeasurableSpaceProperty>,
}

/// A measure space (X,Σ,μ) consists of:
/// - A measurable space (X,Σ)
/// - A measure μ: Σ → [0,∞] satisfying:
///   1. μ(∅) = 0
///   2. μ(∪ᵢ Aᵢ) = Σᵢ μ(Aᵢ) for countable disjoint {Aᵢ} (σ-additivity)
/// - Integration: ∫ f dμ for measurable functions
/// - Almost everywhere properties
/// - Null sets: Sets of measure zero
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct MeasureSpace {
    /// The underlying measurable space
    pub measurable_space: MeasurableSpace,
    /// Properties of the measure
    pub properties: Vec<MeasureSpaceProperty>,
}

/// Properties specific to measure spaces
/// Captures measure-theoretic properties
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MeasureSpaceProperty {
    /// Finite measure property
    /// Related to total measure being finite
    FiniteMeasure(FiniteMeasurePropertyVariant),

    /// σ-finite measure property
    /// Related to countable decomposition
    SigmaFinite(SigmaFinitePropertyVariant),

    /// Regularity property
    /// Related to inner/outer approximations
    Regular(RegularityPropertyVariant),
}

/// Properties related to regularity of a measure
/// Characterizes approximation by nice sets
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RegularityPropertyVariant {
    /// Measure is regular
    /// For all A ∈ Σ:
    /// μ(A) = sup{μ(K) : K ⊆ A, K compact} (inner regularity)
    /// μ(A) = inf{μ(U) : A ⊆ U, U open} (outer regularity)
    /// Examples: Lebesgue measure, Radon measures
    Regular,

    /// Measure is not regular
    /// Lacks inner/outer approximations
    /// Examples: Some pathological measures
    NonRegular,
}

/// Properties related to finiteness of a measure
/// Characterizes the total measure of the space
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FiniteMeasurePropertyVariant {
    /// Space has finite measure
    /// μ(X) < ∞
    /// Examples: Probability spaces, bounded intervals with Lebesgue measure
    Finite,

    /// Space has infinite measure
    /// μ(X) = ∞
    /// Examples: Lebesgue measure on R, counting measure on ℕ
    Infinite,
}

/// Properties related to σ-finiteness of a measure
/// Characterizes decomposability into finite measure sets
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SigmaFinitePropertyVariant {
    /// Space is σ-finite
    /// X = ∪ₙ Xₙ with μ(Xₙ) < ∞
    /// Examples: Lebesgue measure on R, counting measure on countable sets
    SigmaFinite,

    /// Space is not σ-finite
    /// Cannot be written as countable union of finite measure sets
    /// Examples: Counting measure on uncountable sets
    NonSigmaFinite,
}

/// Properties specific to measurable spaces
/// Captures measurability and Borel structure
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MeasurableSpaceProperty {
    /// Measurability structure
    /// Related to σ-algebra structure
    Measurable(MeasurabilityPropertyVariant),

    /// Borel structure
    /// Related to topology-induced measurability
    Borel(BorelPropertyVariant),
}

/// Properties related to measurability of a space
/// Different ways a space can be equipped with measurable structure
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MeasurabilityPropertyVariant {
    /// Space has measurable structure
    /// Has a well-defined σ-algebra of measurable sets
    /// Specifies which type of σ-algebra is used
    Measurable(SigmaAlgebraVariant),

    /// Space is not measurable
    /// No suitable σ-algebra can be defined
    /// Example: Some pathological subsets of R
    NonMeasurable,
}

/// Properties related to Borel structure
/// Characterizes measurable structure induced by topology
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum BorelPropertyVariant {
    /// Space has Borel structure
    /// Has σ-algebra generated by open sets
    /// Natural measurable structure for topological spaces
    Borel,

    /// Space does not have Borel structure
    /// Cannot define σ-algebra using topology
    /// Example: Spaces without topology
    NonBorel,
}

/// An Lp space over a measure space
/// Space of functions f with ∫|f|ᵖ < ∞
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct LpSpace {
    /// The underlying measure space
    pub measure_space: MeasureSpace,
    pub banach_space: Option<BanachSpace>,
    /// The p parameter (1 ≤ p ≤ ∞)
    pub p: f64,
    /// Properties of the Lp space
    pub properties: VariantSet<LpSpaceProperty>,
}
/// Properties specific to Lp spaces
/// Captures integrability and completeness properties
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum LpSpaceProperty {
    /// Exponent p
    /// Determines type of integrability
    Exponent(f64),

    /// Completeness (always true for p ≥ 1)
    /// Related to convergence in Lp norm
    Complete(bool),

    /// Reflexivity (true for 1 < p < ∞)
    /// Related to dual space structure
    Reflexive(bool),

    /// Separability (true for p < ∞)
    /// Related to density properties
    Separable(bool),

    /// Uniform convexity (true for 1 < p < ∞)
    /// Related to geometric structure
    UniformlyConvex(bool),
}
/// A measurable function f: (X,Σ_X) → (Y,Σ_Y) satisfies:
/// - f⁻¹(E) ∈ Σ_X for all E ∈ Σ_Y
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct MeasurableFunction {
    /// Domain measurable space
    pub domain: MeasurableSpace,
    /// Codomain measurable space
    pub codomain: MeasurableSpace,
    /// Properties of the function
    pub properties: VariantSet<MeasurableFunctionProperty>,
}

/// Properties of measurable functions
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MeasurableFunctionProperty {
    /// Integrability properties
    Integrability(IntegrabilityPropertyVariant),
    /// Almost everywhere properties
    AlmostEverywhere(AlmostEverywherePropertyVariant),
    /// Lp space properties
    LpProperty(LpPropertyVariant),
}

/// Types of separability for measurable spaces
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SeparabilityType {
    /// Has countable generating set
    Separable,
    /// No countable generating set
    NonSeparable,
}

/// Types of generation for σ-algebras
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GenerationType {
    /// Generated by topology
    Topological,
    /// Generated by algebra
    Algebraic,
    /// Generated by semiring
    Semiring,
}

/// Types of atomicity for measures
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AtomicityType {
    /// Has atoms
    Atomic,
    /// No atoms
    NonAtomic,
    /// Purely atomic
    PurelyAtomic,
}

/// Types of Radon measures
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RadonType {
    /// Inner regular and locally finite
    Radon,
    /// Not a Radon measure
    NonRadon,
}

/// Types of reflexivity for Lp spaces
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReflexivityType {
    /// Space is reflexive
    Reflexive,
    /// Space is not reflexive
    NonReflexive,
}

/// Types of duality for Lp spaces
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DualityType {
    /// Dual is Lq space
    Conjugate,
    /// Dual is more complex
    NonConjugate,
}

/// Properties specific to function spaces
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FunctionSpaceProperty {
    /// Whether the space is complete
    Complete(bool),
    /// Whether the space is separable
    Separable(bool),
    /// Whether the space is reflexive
    Reflexive(bool),
}

/// Properties specific to Sobolev spaces
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SobolevSpaceProperty {
    /// Order of derivatives
    Order(u32),
    /// Integrability index
    Index(f64),
    /// Whether the space is complete
    Complete(bool),
    /// Whether the space is separable
    Separable(bool),
    /// Whether the space is reflexive
    Reflexive(bool),
}

/// Properties specific to distribution spaces
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DistributionSpaceProperty {
    /// Order of the distribution
    Order(Option<u32>),
    /// Whether the space is nuclear
    Nuclear(bool),
    /// Whether the space is reflexive
    Reflexive(bool),
}

/// Properties related to integrability
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IntegrabilityPropertyVariant {
    /// Integrable (L1)
    Integrable,
    /// Locally integrable
    LocallyIntegrable,
    /// Not integrable
    NonIntegrable,
}

/// Properties that hold almost everywhere
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AlmostEverywherePropertyVariant {
    /// Property holds almost everywhere
    AlmostEverywhere,
    /// Property holds everywhere
    Everywhere,
    /// Property fails on non-negligible set
    NonNegligible,
}

/// Properties specific to Lp spaces
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum LpPropertyVariant {
    /// p = 1 (absolutely integrable)
    L1,
    /// p = 2 (square integrable)
    L2,
    /// p = ∞ (essentially bounded)
    LInfinity,
    /// General p ∈ [1,∞)
    Lp(f64),
}
